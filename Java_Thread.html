<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="Java与多线程

并发：世间万物都可以同时完成很多工作，比如人体可以同时完成呼吸，血液循环，思考问题，用户使用计算机可以听歌，打印文件，玩游戏，这些活动完全可以同时进行，这种思想在Java中被成为并发，而将并发完成的每一件事情成为线程。
多线程：并非所有的程序语言都支持线程，比如JavaScrip"/>
    

    <!--Author-->
    
        <meta name="author" content="JabinGP"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Java与多线程"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Java与多线程

并发：世间万物都可以同时完成很多工作，比如人体可以同时完成呼吸，血液循环，思考问题，用户使用计算机可以听歌，打印文件，玩游戏，这些活动完全可以同时进行，这种思想在Java中被成为并发，而将并发完成的每一件事情成为线程。
多线程：并非所有的程序语言都支持线程，比如JavaScrip"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="JabinGP Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://www.jabingp.cn/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://www.jabingp.cn/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>Java与多线程 - JabinGP Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header addHeader" style="background-image: url('/img/Java.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 ">
                <div class="post-heading">
                    <h1>Java与多线程</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        <div>
                        
                       
                        
                            2018-12-20
                        
                        </div>
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="addpadding">
            
	            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 addFlat">
	            	
	            	<a class="setTags"  href="/tags/学习笔记/">学习笔记</a> 
	            	                <h3 id="Java与多线程"><a href="#Java与多线程" class="headerlink" title="Java与多线程"></a>Java与多线程</h3><hr>
<ul>
<li>并发：世间万物都可以同时完成很多工作，比如人体可以同时完成呼吸，血液循环，思考问题，用户使用计算机可以听歌，打印文件，玩游戏，这些活动完全可以同时进行，这种思想在Java中被成为并发，而将并发完成的每一件事情成为线程。</li>
<li>多线程：并非所有的程序语言都支持线程，比如JavaScript，但在Java中提供了并发机制，程序员可以在程序中执行多个线程，每一个线程完成一个功能，并与其它线程并发执行，这种机制被称为多线程。</li>
</ul>
<h3 id="操作系统与多线程"><a href="#操作系统与多线程" class="headerlink" title="操作系统与多线程"></a>操作系统与多线程</h3><hr>
<blockquote>
<p><em>多线程在不同的系统中的表现是不同的。</em></p>
</blockquote>
<ul>
<li>Java的多线程在Windwos下：Windwos操作系统是多任务操作系统，它以进程为单位。一个进程是一个包含有自身地址的程序，每个独立执行的程序都称为进程，也就是正在执行的程序。系统可以分配给每个进程一段有限的使用CPU的时间（也可以称为CPU时间片），CPU在这段时间中执行某个进程，然后下一个时间片又跳至另一个进程中去执行。<strong>由于CPU转换较快，所以使得每个进程好像是同时执行一样。</strong></li>
</ul>
<h3 id="Java实现多线程"><a href="#Java实现多线程" class="headerlink" title="Java实现多线程"></a>Java实现多线程</h3><hr>
<blockquote>
<p><em>实现Java多线程有两种方法，分别为继承java.lang.Thread类、和实现java.lang.Runnable接口。</em></p>
</blockquote>
<h4 id="继承java-lang-Thread类"><a href="#继承java-lang-Thread类" class="headerlink" title="继承java.lang.Thread类"></a>继承java.lang.Thread类</h4><ol>
<li><p>继承</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Thread类构造方法</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span></span>; <span class="comment">//创建一个新的线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String threadName)</span></span>; <span class="comment">//创建一个名称为threadName的线程对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现run()方法<br>完成线程真正功能的代码放在类的run()方法中。当一个类继承Thread类之后，就可以在该类中覆盖run()方法，将实现该线程的代码放入run()方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用线程，调用run()方法</p>
<p> 调用Thread类中的start()方法执行线程，也就是run()方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String []args)</span><br><span class="line">&#123;</span><br><span class="line">    new ThreadTest().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>当start()方法调用一个已经启动的线程，系统将抛出IllegalThreadStateException异常</strong></p>
</li>
<li><p>实例</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;     <span class="comment">//继承Thread类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.print(count+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadTest().start();			<span class="comment">//调用run()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行结果为</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/....</span><br><span class="line">10 9 8 7 6 5 4 3 2 1 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实现java-lang-Runnable接口"><a href="#实现java-lang-Runnable接口" class="headerlink" title="实现java.lang.Runnable接口"></a>实现java.lang.Runnable接口</h4><blockquote>
<p><em>如果程序员需要继承其他类（非Thread类），而且还要使当前类实现多线程，那么可以通过Runnable接口来实现。</em>实际上，Thread类实现了Runnable接口，其中的run()方法正是对Runnable中的run()方法的具体实现。</p>
</blockquote>
<p>实现Runnable接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联。Thread类有一下两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个构造方法的参数都存在Runnable实例，使用以上构造方法就可以将Runnable实例与Thread实例相关联。</p>
<p>使用Runnable接口启动新的线程的步骤如下：</p>
<ol>
<li><p>建立Runnable对象。</p>
</li>
<li><p>使用参数为Runnable对象的构造方法创建Thread实例。</p>
</li>
<li><p>调用start()方法启动线程。</p>
</li>
</ol>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> java.lang.Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Runnable线程输出"</span>+count);</span><br><span class="line">                    <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><hr>
<ul>
<li>出生：在线程实例start()方法被调用之前都是出生期</li>
<li>就绪：当调用start()后，线程处于就绪状态（又称为可执行状态）</li>
<li>运行：当线程得到系统资源后就进入运行状态</li>
</ul>
<blockquote>
<p>一旦线程进入可执行状态，它会在就绪与运行状态下切换，同时也有可能进入等待，休眠，阻塞或死亡状态。</p>
</blockquote>
<ul>
<li>等待：当处于运行状态下的线程调用Thread类中的wait()方法时，该线程便进入等待状态</li>
<li>休眠：当线程调用Thread类中的sleep()方法时，则会进入休眠状态</li>
<li>阻塞：如果一个线程在运行状态下发出输入/输出请求，该线程将会进入阻塞状态，在其等待输入输出结束时线程进入就绪状态。</li>
<li>死亡：当线程的run()方法执行完毕，线程进入死亡状态</li>
</ul>
<h3 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h3><hr>
<p>线程的休眠依靠调用sleep()方法实现，sleep()方法需要一个参数用于指定线程休眠的毫秒数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sleep()方法在run()方法中调用</span></span><br><span class="line">    	<span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(毫秒数);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，try和catch是语法中规定必须写的，sleep()中接受的是一个毫秒数。</p>
<h3 id="线程的加入"><a href="#线程的加入" class="headerlink" title="线程的加入"></a>线程的加入</h3><hr>
<blockquote>
<p>引言：假如一个读者正在看电视，突然有人上门收水费，读者必须付完水费后才可以继续看电视。</p>
</blockquote>
<p>就像引言说的，当一个线程A需要插入线程B，并要求线程B先执行完毕，然后再执行线程A，此时可以使用Thread类中的join()方法来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">30</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"B线程运行"</span>+count);</span><br><span class="line">                    <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"A线程运行"</span>+count);</span><br><span class="line">                    <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        b.join();	<span class="comment">//调用b</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B线程运行30</span><br><span class="line">..</span><br><span class="line">B线程运行13</span><br><span class="line">A线程运行10</span><br><span class="line">B线程运行12</span><br><span class="line">....</span><br><span class="line">B线程运行1</span><br><span class="line">A线程运行9</span><br><span class="line">A线程运行8</span><br><span class="line">A线程运行7</span><br><span class="line">A线程运行6</span><br><span class="line">A线程运行5</span><br><span class="line">A线程运行4</span><br><span class="line">A线程运行3</span><br><span class="line">A线程运行2</span><br><span class="line">A线程运行1</span><br></pre></td></tr></table></figure>
<p>b启动后被a的run()中的b.join()调用，a线程因此会进入等待状态，等待b线程运行完成才继续运行。</p>
<h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><hr>
<p>新的JDK已经废除了stop()方法，不建议使用stop()方法来停止一个线程的运行。现在提倡在run()方法中使用无限循环的形式，然后使用一个布尔型标记控制循环的停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//设置一个标记变量控制循环是否继续运行，默认值为flase</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">100</span>)isStop=<span class="keyword">true</span>;</span><br><span class="line">                    System.out.println(<span class="string">"A线程正在工作"</span>+count++);</span><br><span class="line">                    <span class="keyword">if</span>(isStop)<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A线程正在工作1</span><br><span class="line">...</span><br><span class="line">A线程正在工作100</span><br></pre></td></tr></table></figure>
<h3 id="线程的礼让"><a href="#线程的礼让" class="headerlink" title="线程的礼让"></a>线程的礼让</h3><hr>
<p><code>Thread</code>类中提供了一种礼让方式，使用<code>yield()</code>方法表示，它只是给当前正处于运行状态的线程一个提醒，告知它可以将资源礼让给其他线程，但这仅仅只是一种暗示，没有任何一种机制保证当前线程会将资源礼让。</p>
<p><code>yield()</code>方法使具有同样优先级的线程有进入可执行状态的机会，当当前线程放弃执行权时会再度回到就绪状态。对于支持多任务的操作系统来说，不需要调用<code>yield()</code>方法，<strong>因为操作系统会为线程自动分配cpu时间片来执行</strong>。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><hr>
<p>Thread 类中包含的成员变量代表了线程的某些优先级，如Thread.MIN_PRIORITY(常数1)、Thread.MAX_PRIORITY(常数10)、Thread.NORM_PRIORITY(常数5)、Thread.MIN_PRIORITY~Thread.MAX_PRIORITY 之间。</p>
<p>在默认情况下其优先级都是Thread.NORM_PRIORITY，每个新产生的线程都继承了父线程的优先级。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><hr>
<blockquote>
<p>两个人同时说话，两个人同时过同一个独木桥，就会发生抢占现象，在多线程中需要防止这些资源访问的冲突，Java提供了线程同步的机制来防止资源访问的冲突。</p>
</blockquote>
<p>实际开发中，使用多线程程序的情况很多，如银行排号系统、火车站售票系统等。这种多线程的程序通常会发生问题，以火车票售票系统为例，在代码中判断当前票数是否大于0、但当两个线程同时访问这段代码时（加入这时只剩下一张票），第一个线程将票售出，与此同时第二个线程也已经执行完成判断当前是否有票的操作，并得出票数大于0的结论，于是它也执行售出操作，这样就会产生负数。所以编写多线程程序的时，应该考虑到线程安全问题。<strong>线程安全问题本质上来源于两个线程同时存取单一对象的数据</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;       <span class="comment">//设置当前总票数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"tickets"</span>+num--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();    <span class="comment">//实例化类对象</span></span><br><span class="line">        Thread tA = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tB = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tC = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tD = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        tA.start();                     <span class="comment">//分别启动线程</span></span><br><span class="line">        tB.start();</span><br><span class="line">        tC.start();</span><br><span class="line">        tD.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickets10</span><br><span class="line">tickets9</span><br><span class="line">tickets10</span><br><span class="line">tickets8</span><br><span class="line">tickets7</span><br><span class="line">tickets5</span><br><span class="line">tickets6</span><br><span class="line">tickets4</span><br><span class="line">tickets3</span><br><span class="line">tickets3</span><br><span class="line">tickets2</span><br><span class="line">tickets1</span><br><span class="line">tickets0</span><br><span class="line">tickets-1</span><br><span class="line">tickets-2</span><br></pre></td></tr></table></figure>
<p>以上实例中最后打印的票数为负值，这样就出了问题，这是由于同时创建了四个线程，这四个线程执行run()方法，在num变量为1时，线程1、2、3、4都对num变量有存储功能，当线程1执行run()方时，还没有来的级做递减操作，就指定它调用sleep()方法进入休眠状态，此时线程2、3、4都进入了run()方法，发现num变量依然大于0，但此时线程1休眠时间已到，将num变量值递减，同时线程2、3、4也都对num变量进行递减操作。</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><hr>
<p>基本上所有解决多线程冲突问题的方法都是采用给定时间只允许一个线程访问共享资源，这时就需要给共享资源上一道锁。这就好比一个人上洗手间，他进入洗手间后会将门锁上，出来时再将锁打开，然后其他人才可以进入。</p>
<h4 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h4><p>在java中提供了同步机制，可以有效防止资源冲突。同步机制使用<code>synchronized</code>关键字，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">""</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"tickets"</span>+ --num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread tA = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tB = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tC = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread tD = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">        tC.start();</span><br><span class="line">        tD.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/bin/java...</span><br><span class="line">tickets9</span><br><span class="line">tickets8</span><br><span class="line">tickets7</span><br><span class="line">tickets6</span><br><span class="line">tickets5</span><br><span class="line">tickets4</span><br><span class="line">tickets3</span><br><span class="line">tickets2</span><br><span class="line">tickets1</span><br><span class="line">tickets0</span><br></pre></td></tr></table></figure>
<p>通常将共享资源的操作放置在synchronized定义的区域内，这样当其他线程也获取到了这个锁时，必须等待锁被释放时才能进入该区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步块是如何保证单一线程运行的？Object为任意一个对象，每个对象都存在一个标志位，并具有两个值，分别为0和1.一个线程运行到同步块时首先检查该对象的标记位，如果为0状态，表明此同步块中存在其他线程在运行。该线程则进入就绪状态直到同步块中的线程执行完代码并且标记为被设置为1后，该线程才能执行同步块中的代码。</p>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>同步方法就是在方法前面修饰synchronized 关键字的方法，其语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当某个对象调用了同步方法时，该对象上的其他同步方法必须等待该方法执行完毕后才能被执行。必须将每个能访问共享资源的方法修饰为synchronized，否则就会出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">()</span></span>&#123;    <span class="comment">//定义同步方法</span></span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);       </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"tickets"</span>+ --num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            doit();			<span class="comment">//在run()方法中调用该同步方法</span></span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

	
	                
	            </div>
	            	          </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 JabinGP<br></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>